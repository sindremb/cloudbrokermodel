model CarrierBrokerPathModel
uses "mmxprs"; !gain access to the Xpress-Optimizer solver

options explterm
options noimplicit

uses "mmxprs", "mmsystem";

parameters
	! Data file to read from
	Data = 'data/sm_mappings.txt';
end-parameters

declarations
	timetracker:	real; ! used to log timestamps for time consumption output
end-declarations

writeln("Building model...");
timetracker := timestamp; ! assigns current "timestamp" to timetracker

!setparam("XPRS_presolve", 0);	! uncomment to turn of presolve
setparam("XPRS_maxtime", 3600); ! maximum number of seconds for optimisation

!!!!!!!!!!!!!!!!!!!!!!!!
! Sets
!!!!!!!!!!!!!!!!!!!!!!!!

declarations
! Set sizes
	n_Customers: 			integer; ! number of customers
	n_Services:				integer; ! number of services
	n_Nodes:				integer; ! number of nodes in total
	n_Paths:				integer; ! number of paths
	n_Mappings:				integer; ! number of mappings
	
! Sets	
	Customers:				set of integer; 
	! Used as shorthand for 'cc in Customers, ss in S_ServiceForCustomer(cc)' when cc is not needed 
	Services:				set of integer;
	! Set of nodes in the network. 
	! - First we have the customer nodes, then the internal nodes, the the provider nodes.
	Nodes:					set of integer;
	! Set of paths
	Paths:					set of integer; 
	
end-declarations

initializations from Data
	n_Customers;
	n_Services;
	n_Nodes;
	n_Paths;
	n_Mappings;
end-initializations
	
Customers:= 1..n_Customers;
Services:= 1..n_Services;  
Nodes:= 1..n_Nodes;
Paths := 1..n_Paths;
Mappings := 1..n_Mappings;

finalize(Customers);
finalize(Services);
finalize(Nodes);
finalize(Paths);
finalize(Mappings);

!!!!!!!!!!!!!!!!!!!!!!!
! Parameters
!!!!!!!!!!!!!!!!!!!!!!!

declarations
	!R_Revenue from serving each customer
	R_Revenue:					dynamic array(Customers)	 of real;
	!Bandwidth capacity between each pair of nodes
	F_BandwidthCap:				dynamic array(Nodes,Nodes)	 of real;
	!set of paths  using each link
	L_PathsUsingLink:			dynamic array(Nodes,Nodes) of set	of integer;
	L_PathsUsingLinkBackup:		dynamic array(Nodes,Nodes) of set	of integer;
	!bandwidth usage for path
	U_PathBandwidthUsage:		dynamic array(Nodes,Nodes,Paths)	of real;
	U_PathBandwidthUsageBackup:	dynamic array(Nodes,Nodes,Paths)	of real;
	! cost of using path k
	C_PathCost:					dynamic array(Paths)				of real;
	! cost per bandwidth used for backup paths on arc
	C_BackupCost:				dynamic array(Nodes,Nodes)			of real;
	! services of services for customer
	S_ServiceForCustomer:		set of set of integer;
	!Possible mappings for each pair of service and provider
	K_Mappings:					dynamic array(Services) of set of integer;
	! mappings using path as primary path
	P_MappingPerPath:			dynamic array(Paths) of set of integer;
	! mappings using path as backup path
	B_MappingsPerBackupPath:	dynamic array(Paths) of set of integer;
end-declarations


initialisations from Data	
	R_Revenue;
	F_BandwidthCap;	
	K_Mappings;
	L_PathsUsingLink;
	L_PathsUsingLinkBackup;
	U_PathBandwidthUsage;
	U_PathBandwidthUsageBackup;
	C_PathCost;
	C_BackupCost;
	S_ServiceForCustomer;
	P_MappingsPerPath;
	B_MappingsPerBackupPath;
end-initialisations


declarations	
	!Variables
	! - y: binary, serving of a customer
	y_Serve:			dynamic array (Customers)					of mpvar;
	! - u: binary, indicates which paths are used
	u_UseMapping:		dynamic array (Mappings)						of mpvar; 
	! - lambda: continous, amount of capacity reserved on a link for backup
	l_Lambda:			dynamic array(Nodes,Nodes)					of mpvar;
	! - l: binary, indicates if two services' primary paths overlap
	l_Overlap:			dynamic array(Services,Services)			of mpvar;
end-declarations

! - for all customers
forall(cc in Customers) do
	create(y_Serve(cc));
	y_Serve(cc) is_binary;
end-do

forall(mm in Mappings) do
	create(u_UseMapping(mm));
	u_UseMapping(mm) is_binary;
end-do

forall (nn in Nodes, mm in Nodes) do
	create(l_Lambda(nn,mm));
end-do

forall (ss in Services, zz in Services | ss < zz) do
	create(l_Overlap(ss,zz));
	l_Overlap(ss,zz) is_binary;
end-do


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! CONSTRAINTS
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

declarations
! Objective function
	Total_Profits:																linctr;

! Constraints
	UsePath:						dynamic array(Services)							of linctr;
	PathArcBandwidth:				dynamic array(Nodes,Nodes)						of linctr;
	TotalBackup:					dynamic array(Nodes,Nodes)						of linctr;
	MaximumBackup:					dynamic array(Nodes,Nodes,Services)				of linctr;
	Overlap:						dynamic array(Nodes,Nodes,Services, Services)	of linctr;
	ServiceOverlap:					dynamic array(Nodes,Nodes,Services, Services)	of linctr;
end-declarations

write(" - obj. fn. ..");	

! OBJECTIVE FUNCTION
! - total profits from serving customers
Total_Profits := sum (cc in Customers) (
					! R_Revenue from serving customer (if served)
					R_Revenue(cc)*y_Serve(cc)
				)
				- 
				! cost for all paths used as main paths
				sum(kk in Paths) (sum(mm in P_MappingsPerPath(kk)) (
					!cost for using a path
					C_PathCost(kk)*u_UseMapping(mm))
				)
				-
				! cost of bandwidth reserved to support backup paths
				sum(nn in Nodes) (
					sum(mm in Nodes) (
						C_BackupCost(nn, mm)*l_Lambda(nn, mm)
					)
				);

write("DONE\n - use path cnstr. ..");	



! USE PATH CONSTRAINTS
! If a service is placed at a provider, a path connecting to that provider location must be chosen
forall(cc in Customers) do
	forall(ss in S_ServiceForCustomer(cc) | exists(K_Mappings(ss))) do
		UsePath(ss) := sum(kk in K_Mappings(ss)) u_UseMapping(kk) -y_Serve(cc) =0;
	end-do
end-do

write("DONE\n - arc cap cnstr. ..");	

! ARC CAPACITY CONSTRAINT
! The total used bandwidth for primary paths and reserved for backup paths must not exceed the
! arcs capacity
forall(nn in Nodes, mm in Nodes | exists(L_PathsUsingLink(nn,mm))) do
	PathArcBandwidth(nn,mm) := sum(kk in L_PathsUsingLink(nn,mm)) U_PathBandwidthUsage(nn,mm,kk)*(sum(pp in P_MappingsPerPath(kk))u_UseMapping(pp)) + l_Lambda(nn,mm) 
		<= F_BandwidthCap(nn,mm);
end-do

write("DONE\n - backup path bw use cnstr. 1 ..");

! ACCUMULATIVE BACKUP PATHS BANDWIDTH CONSTRAINTS
! bandwidth reserved for backup paths on an arc is at least a fraction of the total bandwidth of all
! backup paths using that arc
forall( nn in Nodes, mm in Nodes | exists(L_PathsUsingLink(nn,mm))) do
	TotalBackup(nn,mm) := 0.3* sum(kk in L_PathsUsingLinkBackup(nn,mm))U_PathBandwidthUsageBackup(nn,mm,kk)*(sum(pp in P_MappingsPerBackupPath(kk))u_UseMapping(pp))
		<= l_Lambda(nn,mm);
end-do

write("DONE\n - backup path bw use cnstr. 2 ..");



! MIN BACKUP PATH BANDWIDTH CONSTRAINT
! bandwidth reserved for backup paths must be at least as high as the bandwidth required by the
! most demanding backup path alone not also having its primary path at the same arc
! - if primary path goes down elsewhere - sufficient bandwidth is released for the backup path
!   at this arc
forall (cc in Customers) do
	forall(ss in S_ServiceForCustomer(cc)) do
		forall(nn in Nodes, mm in Nodes | exists(L_PathsUsingLinkBackup(nn,mm))) do
			MaximumBackup(nn,mm,ss) := 
				!sum(pp in (P_MappingsPerPath(L_PathsUsingLinkBackup(nn,mm))*K_Mappings(ss)))
				!(U_PathBandwidthUsageBackup(nn,mm,kk)-U_PathBandwidthUsage(nn,mm,kk))*u_UseMapping(pp) 
				!<= l_Lambda(nn,mm);
			 sum(kk in L_PathsUsingLinkBackup(nn,mm))(U_PathBandwidthUsageBackup(nn,mm,kk)-U_PathBandwidthUsage(nn,mm,kk))
			 *sum(pp in P_MappingsPerPath(kk)*K_Mappings(ss))(u_UseMapping(pp)) 
				<= l_Lambda(nn,mm); ) 
		end-do
	end-do
end-do

writeln("DONE\n - service and backup overlap cnstrs.");

forall(cc in Customers, qq in Customers) do
	forall(ss in S_ServiceForCustomer(cc), zz in S_ServiceForCustomer(qq) | ss <> zz and ss < zz) do
		writeln("  - service pair: ", ss, ", ", zz);
		forall(nn in Nodes, mm in Nodes | 	exists(L_PathsUsingLink(nn,mm)) 				! There are some paths using this arc
											!and K_Paths(ss)*L_PathsUsingLink(nn,mm) <> {}	! Service ss has paths using this link
											!and K_Paths(zz)*L_PathsUsingLink(nn,mm) <> {}	! Service zz has paths using this link
										) do
		
			! SERVICE PATH OVERLAP CONSTRAINTS
			! Two services have overlapping primary paths if for any arc both paths are represented
			ServiceOverlap(nn,mm,ss,zz):=
				sum(kk in L_PathsUsingLink(nn,mm))(sum(pp in K_Mappings(ss)*P_MappingsPerPath(kk)))(u_UseMapping(pp))
				!sum(kk in (K_Paths(ss)*L_PathsUsingLink(nn,mm))) (u_UsePath(kk))
				+
				sum(kk in L_PathsUsingLink(nn,mm))(sum(pp in K_Mappings(zz)*P_MappingsPerPath(kk)))(u_UseMapping(pp))
				!sum(kk in (K_Paths(zz)*L_PathsUsingLink(nn,mm))) (u_UsePath(kk))
				-1
				<= l_Overlap(ss, zz);
			
			! BACKUP PATH OVERLAP CONSTRAINT
			! backup paths may not overlap at an arc if their primary paths overlap anywhere, unless
			! one of the primary paths also overlap at that specific arc
			Overlap(nn,mm,ss,zz):= 
				sum(kk in L_PathsUsingLink(nn,mm))(sum(pp in K_Mappings(ss)*P_MappingsPerBackupPath(kk)))(u_UseMapping(pp))
				!sum(kk in (K_Paths(ss)*L_PathsUsingLinkBackup(nn,mm))) (u_UsePath(kk))
				+
				sum(kk in L_PathsUsingLink(nn,mm))(sum(pp in K_Mappings(zz)*P_MappingsPerBackupPath(kk)))(u_UseMapping(pp))
				!sum(kk in (K_Paths(zz)*L_PathsUsingLinkBackup(nn,mm))) (u_UsePath(kk))
				+ l_Overlap(ss, zz)
				<= 2;
		end-do
	end-do
end-do

writeln("  - DONE");




!!!! Ikke endret utskrift enda!!!!
writeln("Model building completed in ", timestamp - timetracker, " seconds");

writeln("Solving model...");
timetracker := timestamp;
maximize(Total_Profits);

if (getprobstat=XPRS_OPT) then
	writeln("Model solved in ", timestamp - timetracker," seconds");
else
	writeln("Model was not solved after ", timestamp - timetracker," seconds");
end-if

writeln("\nTotal Profits: ", getobjval);

writeln("\nTotal Backup Costs: ", sum(nn in Nodes)(sum(mm in Nodes)(C_BackupCost(nn, mm)*getsol(l_Lambda(nn, mm)))));

! for all customers
forall(cc in Customers) do
	! Check if customer is served
	if (getsol(y_Serve(cc)) > 0.1) then
		! output served customer and generated profits for customer
		writeln("\n\nCustomer ", cc, " (node ",cc,") is being served\n - R_Revenue: ",
			R_Revenue(cc)*getsol(y_Serve(cc)));
		forall(ss in S_ServiceForCustomer(cc) | exists(K_Paths(ss))) do
			forall(kk in K_Paths(ss)) do
				if (getsol(u_UsePath(kk)) > 0.1) then
					writeln("  - Service ",ss," uses path ",kk," , cost: ",C_PathCost(kk));
				end-if
			end-do
		end-do
	end-if
end-do
				

end-model
