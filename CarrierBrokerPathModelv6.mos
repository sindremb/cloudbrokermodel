model CarrierBrokerPathModel
uses "mmxprs"; !gain access to the Xpress-Optimizer solver

options explterm
options noimplicit

uses "mmxprs", "mmsystem";

parameters
	! Data file to read from
	Data = 'data/sm_multi.txt';
	! Minimum proportion of total backup requirement reserved on an arc
	MinBackupProportion = 0.3;
end-parameters

declarations
	timetracker:	real; ! used to log timestamps for time consumption output
end-declarations

writeln("Building model...");
timetracker := timestamp; ! assigns current "timestamp" to timetracker

!setparam("XPRS_presolve", 0);	! uncomment to turn of presolve
setparam("XPRS_maxtime", 3600); ! maximum number of seconds for optimisation

!!!!!!!!!!!!!!!!!!!!!!!!
! Sets
!!!!!!!!!!!!!!!!!!!!!!!!

declarations
! Set sizes
	n_Customers: 			integer; ! number of customers
	n_Services:				integer; ! number of services
	n_Nodes:				integer; ! number of nodes in total
	n_Paths:				integer; ! number of paths
	n_Mappings:				integer; ! number of mappings
	
! Sets	
	Customers:				set of integer; 
	! Used as shorthand for 'cc in Customers, ss in S_ServiceForCustomer(cc)' when cc is not needed 
	Services:				set of integer;
	! Set of nodes in the network. 
	! - First we have the customer nodes, then the internal nodes, the the provider nodes.
	Nodes:					set of integer;
	! Set of paths
	Paths:					set of integer; 
	! Set of mappings
	Mappings:				set of integer;
	
end-declarations

initializations from Data
	n_Customers;
	n_Services;
	n_Nodes;
	n_Paths;
	n_Mappings;
end-initializations
	
Customers:= 1..n_Customers;
Services:= 1..n_Services;  
Nodes:= 1..n_Nodes;
Paths := 1..n_Paths;
Mappings := 1..n_Mappings;

finalize(Customers);
finalize(Services);
finalize(Nodes);
finalize(Paths);
finalize(Mappings);

!!!!!!!!!!!!!!!!!!!!!!!
! Parameters
!!!!!!!!!!!!!!!!!!!!!!!

declarations
	!R_Revenue from serving each customer
	R_Revenue:					dynamic array(Customers)	 of real;
	!Bandwidth capacity between each pair of nodes
	F_BandwidthCap:				dynamic array(Nodes,Nodes)	 of real;
	!set of paths  using each link
	L_PathsUsingLink:			dynamic array(Nodes,Nodes) of set	of integer;
	!bandwidth usage for path
	U_PathBandwidthUsage:		dynamic array(Nodes,Nodes,Paths)	of real;
	! cost of using path k
	C_PathCost:					dynamic array(Paths)				of real;
	! cost per bandwidth used for backup paths on arc
	C_BackupCost:				dynamic array(Nodes,Nodes)			of real;
	! services of services for customer
	S_ServiceForCustomer:		set of set of integer;
	!Possible mappings for each pair of service and provider
	M_MappingsPerService:		dynamic array(Services) of set of integer;
	! mappings using path as primary path
	M_PrimaryMappingsPerPath:	dynamic array(Paths) of set of integer;
	! mappings using path as backup path
	M_BackupMappingsPerPath:	dynamic array(Paths) of set of integer;
end-declarations


initialisations from Data	
	R_Revenue;
	F_BandwidthCap;
	L_PathsUsingLink;
	U_PathBandwidthUsage;
	C_PathCost;
	C_BackupCost;
	S_ServiceForCustomer;
	M_MappingsPerService;
	M_PrimaryMappingsPerPath;
	M_BackupMappingsPerPath;
end-initialisations


declarations	
	!Variables
	! - y: binary, serving of a customer
	y_Serve:			dynamic array (Customers)					of mpvar;
	! - u: binary, indicates which paths are used
	w_UseMapping:		dynamic array (Mappings)					of mpvar; 
	! - lambda: continous, amount of capacity reserved on a link for backup
	l_Lambda:			dynamic array(Nodes,Nodes)					of mpvar;
	! - q: continous, amount of backup capacity needed on an arc for a service
	q_backupPerService:	dynamic array(Nodes, Nodes, Services)		of mpvar;
	! - l: binary, indicates if two services' primary paths overlap
	l_Overlap:			dynamic array(Services,Services)			of mpvar;
end-declarations

! - for all customers
forall(cc in Customers) do
	create(y_Serve(cc));
	y_Serve(cc) is_binary;
end-do

forall(mm in Mappings) do
	create(w_UseMapping(mm));
	w_UseMapping(mm) is_binary;
end-do

forall (ii in Nodes, jj in Nodes | exists(F_BandwidthCap(ii,jj))) do
	create(l_Lambda(ii,jj));
end-do

forall (ii in Nodes, jj in Nodes, ss in Services | exists(F_BandwidthCap(ii,jj))) do
	create(q_backupPerService(ii,jj,ss));
end-do

forall (ss in Services, zz in Services | ss < zz) do
	create(l_Overlap(ss,zz));
	l_Overlap(ss,zz) is_binary;
end-do


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! CONSTRAINTS
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

declarations
! Objective function
	Total_Profits:																linctr;

! Constraints
	AllocateMapping:				dynamic array(Services)							of linctr;
	PathArcBandwidth:				dynamic array(Nodes,Nodes)						of linctr;
	SumBackupLimit:					dynamic array(Nodes,Nodes)						of linctr;
	MinBackupLimit:					dynamic array(Nodes,Nodes,Services)				of linctr;
	BackupReqPerService:			dynamic array(Nodes,Nodes,Services)				of linctr;
	Overlap:						dynamic array(Nodes,Nodes,Services, Services)	of linctr;
	ServiceOverlap:					dynamic array(Nodes,Nodes,Services, Services)	of linctr;
end-declarations

write(" - obj. fn. ..");	

! OBJECTIVE FUNCTION
! - total profits from serving customers
Total_Profits := sum (cc in Customers) (
					! R_Revenue from serving customer (if served)
					R_Revenue(cc)*y_Serve(cc)
				)
				- 
				! for all paths
				sum(kk in Paths) (
					! for all mappings using path as primary
					sum(mm in M_PrimaryMappingsPerPath(kk)) (
						! add cost for using path if mapping is used
						C_PathCost(kk)*w_UseMapping(mm)
					)
				)
				-
				! for each arc
				sum(nn in Nodes, mm in Nodes | exists(F_BandwidthCap(nn,mm)))(
					! add cost of bandwidth reserved for backup paths
					C_BackupCost(nn, mm)*l_Lambda(nn, mm)
				);

write("DONE\n - use path cnstr. ..");	

! ALLOCATE MAPPING CONSTRAINTS
! All services of a customer that is to be served must be allocated one mapping
forall(cc in Customers) do
	forall(ss in S_ServiceForCustomer(cc) | exists(M_MappingsPerService(ss))) do
		AllocateMapping(ss) := sum(kk in M_MappingsPerService(ss)) w_UseMapping(kk) = y_Serve(cc);
	end-do
end-do

write("DONE\n - arc cap cnstr. ..");	

! ARC CAPACITY CONSTRAINT
! The total used bandwidth for primary paths and reserved for backup paths must not exceed the
! arcs capacity
forall(nn in Nodes, mm in Nodes | exists(L_PathsUsingLink(nn,mm))) do
	PathArcBandwidth(nn,mm) := 
		! for each path using link
		sum(kk in L_PathsUsingLink(nn,mm)) (
			! add bw req for path for each mapping using path being used
			U_PathBandwidthUsage(nn,mm,kk)
			*(sum(pp in M_PrimaryMappingsPerPath(kk))w_UseMapping(pp))
		)
		! add bandwidth reserved for backup paths on arc
		+ l_Lambda(nn,mm) 
		<= F_BandwidthCap(nn,mm);
end-do

write("DONE\n - backup path bw use cnstr. 1 ..");

! ACCUMULATIVE BACKUP PATHS BANDWIDTH CONSTRAINTS
! bandwidth reserved for backup paths on an arc is at least a fraction of the total bandwidth of all
! backup paths using that arc
forall( ii in Nodes, jj in Nodes | exists(L_PathsUsingLink(ii,jj))) do
	SumBackupLimit(ii,jj) := 
		MinBackupProportion*
		sum(cc in Customers) (
			sum(ss in S_ServiceForCustomer(cc)) (
				q_backupPerService(ii,jj,ss)
			)
		)
		<= l_Lambda(ii,jj);
end-do

write("DONE\n - backup path bw use cnstr. 2 ..");

! MIN BACKUP PATH BANDWIDTH CONSTRAINT
! bandwidth reserved for backup paths must be at least as high as the bandwidth required by the
! the most demaning single service
forall(ii in Nodes, jj in Nodes | exists(L_PathsUsingLink(ii,jj))) do
	forall (cc in Customers) do
		forall(ss in S_ServiceForCustomer(cc)) do		
			MinBackupLimit(ii,jj,ss) :=
				q_backupPerService(ii,jj,ss) <= l_Lambda(ii,jj);  
		end-do
	end-do
end-do

write("DONE\n - backup path bw use cnstr. 3 ..");

! BACKUP REQUIREMENT FOR SERVICE AT ARC CONSTRAINT
! a service will require a backup reservation at an arc equal to its backup link requirement
! minus the capacity used by the primary path at the same link (as this capacity will be released
! if the primary path goes down and the backup is needed)
forall(ii in Nodes, jj in Nodes | exists(L_PathsUsingLink(ii,jj))) do
	forall (cc in Customers) do
		forall(ss in S_ServiceForCustomer(cc)) do		
			BackupReqPerService(ii,jj,ss) :=
				! sum for all paths using this link
				sum(kk in L_PathsUsingLink(ii,jj))(
					! service's backup requirement on arc (if path is used)
					U_PathBandwidthUsage(ii,jj,kk)
					*sum(mm in M_BackupMappingsPerPath(kk)*M_MappingsPerService(ss))(w_UseMapping(mm))
					-
					! service's primary requirement on arc (if path is used)
					U_PathBandwidthUsage(ii,jj,kk)
					*sum(mm in M_PrimaryMappingsPerPath(kk)*M_MappingsPerService(ss))(w_UseMapping(mm))
			 	) 
				<= q_backupPerService(ii,jj,ss);  
		end-do
	end-do
end-do

writeln("DONE\n - service and backup overlap cnstrs.");

forall(cc in Customers, qq in Customers) do
	forall(ss in S_ServiceForCustomer(cc), zz in S_ServiceForCustomer(qq) | ss <> zz and ss < zz) do
		writeln("  - service pair: ", ss, ", ", zz);
		forall(ii in Nodes, jj in Nodes | 	exists(L_PathsUsingLink(ii,jj)) 	! There is an entry for paths using this link
											!and L_PathsUsingLink(nn,mm) <> {}	! Entry of paths using link is not empty
											!and K_Paths(zz)*L_PathsUsingLink(nn,mm) <> {}	! Service zz has paths using this link
										) do
		
			! SERVICE PATH OVERLAP CONSTRAINTS
			! Two services have overlapping primary paths if for any arc both paths are represented
			ServiceOverlap(ii,jj,ss,zz):=
				sum(kk in L_PathsUsingLink(ii,jj))(sum(mm in M_MappingsPerService(ss)*M_PrimaryMappingsPerPath(kk))(w_UseMapping(mm)))
				!sum(kk in (K_Paths(ss)*L_PathsUsingLink(nn,mm))) (u_UsePath(kk))
				+
				sum(kk in L_PathsUsingLink(ii,jj))(sum(mm in M_MappingsPerService(zz)*M_PrimaryMappingsPerPath(kk))(w_UseMapping(mm)))
				!sum(kk in (K_Paths(zz)*L_PathsUsingLink(nn,mm))) (u_UsePath(kk))
				-l_Overlap(ss, zz)
				<= 1;
			
			! BACKUP PATH OVERLAP CONSTRAINT
			! backup paths may not overlap at an arc if their primary paths overlap anywhere
			Overlap(ii,jj,ss,zz):= 
				sum(kk in L_PathsUsingLink(ii,jj))(sum(mm in M_MappingsPerService(ss)*M_BackupMappingsPerPath(kk))(w_UseMapping(mm)))
				!sum(kk in (K_Paths(ss)*L_PathsUsingLinkBackup(nn,mm))) (u_UsePath(kk))
				+
				sum(kk in L_PathsUsingLink(ii,jj))(sum(mm in M_MappingsPerService(zz)*M_BackupMappingsPerPath(kk))(w_UseMapping(mm)))
				!sum(kk in (K_Paths(zz)*L_PathsUsingLinkBackup(nn,mm))) (u_UsePath(kk))
				+ l_Overlap(ss, zz)
				<= 2;
		end-do
	end-do
end-do

writeln("  - DONE");

writeln("\nModel building completed in ", timestamp - timetracker, " seconds");

writeln("\nSolving model...");
timetracker := timestamp;
maximize(Total_Profits);

if (getprobstat=XPRS_OPT) then
	writeln("\nModel solved in ", timestamp - timetracker," seconds");
else
	writeln("\nModel was not solved after ", timestamp - timetracker," seconds");
end-if

writeln("\nTotal Profits: ", getobjval);

writeln("\nTotal Backup Costs: ", sum(nn in Nodes)(sum(mm in Nodes)(C_BackupCost(nn, mm)*getsol(l_Lambda(nn, mm)))));

! for all customers

forall(cc in Customers) do
	! Check if customer is served
	if (getsol(y_Serve(cc)) > 0.1) then
		! output served customer and generated profits for customer
		writeln(
			"\nCustomer ", cc, " (node ",cc,") is being served\n - R_Revenue: ",
			R_Revenue(cc)*getsol(y_Serve(cc))
		);
		forall(ss in S_ServiceForCustomer(cc)) do
			forall(mm in M_MappingsPerService(ss)) do
				if (getsol(w_UseMapping(mm)) > 0.1) then
					writeln("  - Service ",ss," uses mapping ",mm);
					forall(kk in Paths) do
						forall(jj in M_PrimaryMappingsPerPath(kk) | jj = mm) do
							writeln("   - Primary path: ", kk, ", cost: ", C_PathCost(kk));
						end-do
					end-do
					forall(kk in Paths) do
						forall(jj in M_BackupMappingsPerPath(kk) | jj = mm) do
							writeln("   - Backup path: ", kk);
						end-do
					end-do
				end-if
			end-do
		end-do
	end-if
end-do

writeln("\nTotal backup usage");
writeln(
	strfmt("arc ",10), 
	strfmt("reserved",10),
	strfmt("max req",10),
	strfmt("sum reqs*",10),
	strfmt("cost/bw",10),
	strfmt("paths",10)
);

declarations
	temp: real;
end-declarations

forall(ii in Nodes, jj in Nodes | exists(L_PathsUsingLink(ii,jj))) do
	temp := 0.0;
	forall(cc in Customers) do
		forall(ss in S_ServiceForCustomer(cc) | exists(M_MappingsPerService(ss))) do
			if(sum(kk in L_PathsUsingLink(ii,jj))(
					U_PathBandwidthUsage(ii,jj,kk)
					* sum(mm in M_BackupMappingsPerPath(kk)*M_MappingsPerService(ss))getsol(w_UseMapping(mm))
					-
					U_PathBandwidthUsage(ii,jj,kk)
					* sum(mm in M_PrimaryMappingsPerPath(kk)*M_MappingsPerService(ss))getsol(w_UseMapping(mm))		
				) > temp) then
				temp := (
					sum(kk in L_PathsUsingLink(ii,jj))(
						U_PathBandwidthUsage(ii,jj,kk)
						* sum(mm in M_BackupMappingsPerPath(kk)*M_MappingsPerService(ss))getsol(w_UseMapping(mm))
						-
						U_PathBandwidthUsage(ii,jj,kk)
						* sum(mm in M_PrimaryMappingsPerPath(kk)*M_MappingsPerService(ss))getsol(w_UseMapping(mm))
					)
				);
			end-if
		end-do
	end-do
	if(getsol(l_Lambda(ii,jj)) > 0.001) then
		write(
			strfmt("("+ ii+ ", "+ jj+ ")",10),
			strfmt(+getsol(l_Lambda(ii,jj)), 10),
			strfmt(temp, 10),
			strfmt((sum(ss in Services)getsol(q_backupPerService(ii,jj,ss))), 10),
			strfmt(C_BackupCost(ii,jj), 10),
			"     "
		);
		forall(kk in L_PathsUsingLink(ii,jj)) do
			forall(mm in M_BackupMappingsPerPath(kk) | getsol(w_UseMapping(mm)) > 0.001) do
				write(kk, ", ");
			end-do
		end-do
		write("\n");
	end-if
end-do

end-model
