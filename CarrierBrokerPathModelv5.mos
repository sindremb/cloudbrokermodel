model CarrierBrokerPathModel
uses "mmxprs"; !gain access to the Xpress-Optimizer solver

options explterm
options noimplicit

uses "mmxprs", "mmsystem";

parameters
	! Data file to read from
	Data = 'mediumv2.txt';
end-parameters

declarations
	timetracker:	real; ! used to log timestamps for time consumption output
end-declarations

writeln("Building model...");
timetracker := timestamp; ! assigns current "timestamp" to timetracker

!setparam("XPRS_presolve", 0);	! uncomment to turn of presolve
setparam("XPRS_maxtime", 3600); ! maximum number of seconds for optimisation

!!!!!!!!!!!!!!!!!!!!!!!!
! Sets
!!!!!!!!!!!!!!!!!!!!!!!!

declarations
! Set sizes
	n_Customers: 			integer; ! number of customers
	n_Services:				integer; ! number of services
	n_Nodes:				integer; ! number of nodes in total
	n_Paths:				integer; ! number of paths
	
! Sets	
	Customers:				set of integer; 
	! Used as shorthand for 'cc in Customers, ss in S_ServiceForCustomer(cc)' when cc is not needed 
	Services:				set of integer;
	! Set of nodes in the network. 
	! - First we have the customer nodes, then the internal nodes, the the provider nodes.
	Nodes:					set of integer;
	! Set of paths
	Paths:					set of integer; 
	
end-declarations

initializations from Data
	n_Customers;
	n_Services;
	n_Nodes;
	n_Paths;
end-initializations
	
Customers:= 1..n_Customers;
Services:= 1..n_Services;  
Nodes:= 1..n_Nodes;
Paths := 1..n_Paths;

finalize(Customers);
finalize(Services);
finalize(Nodes);
finalize(Paths);

!!!!!!!!!!!!!!!!!!!!!!!
! Parameters
!!!!!!!!!!!!!!!!!!!!!!!

declarations
	!R_Revenue from serving each customer
	R_Revenue:					dynamic array(Customers)	 of real;
	!Bandwidth capacity between each pair of nodes
	F_BandwidthCap:				dynamic array(Nodes,Nodes)	 of real;
	!Possible paths for each pair of service and provider
	K_Paths:					dynamic array(Services) of set of integer;
	!set of paths  using each link
	L_PathsUsingLink:			dynamic array(Nodes,Nodes) of set	of integer;
	L_PathsUsingLinkBackup:		dynamic array(Nodes,Nodes) of set	of integer;
	!bandwidth usage for path
	U_PathBandwidthUsage:		dynamic array(Nodes,Nodes,Paths)	of real;
	U_PathBandwidthUsageBackup:	dynamic array(Nodes,Nodes,Paths)	of real;
	! cost of using path k
	C_PathCost:					dynamic array(Paths)				of real;
	! cost per bandwidth used for backup paths on arc
	C_BackupCost:				dynamic array(Nodes,Nodes)			of real;
	! services of services for customer
	S_ServiceForCustomer:		set of set of integer; 

end-declarations


initialisations from Data	
	R_Revenue;
	F_BandwidthCap;	
	K_Paths;
	L_PathsUsingLink;
	L_PathsUsingLinkBackup;
	U_PathBandwidthUsage;
	U_PathBandwidthUsageBackup;
	C_PathCost;
	C_BackupCost;
	S_ServiceForCustomer;
end-initialisations


declarations	
	!Variables
	! - y: binary, serving of a customer
	y_Serve:			dynamic array (Customers)					of mpvar;
	! - u: binary, indicates which paths are used
	u_UsePath:			dynamic array (Paths)						of mpvar; 
	! - lambda: continous, amount of capacity reserved on a link for backup
	l_Lambda:			dynamic array(Nodes,Nodes)					of mpvar;
	! - l: binary, indicates if two services' primary paths overlap
	l_Overlap:			dynamic array(Services,Services)			of mpvar;
end-declarations

! - for all customers
forall(cc in Customers) do
	create(y_Serve(cc));
	y_Serve(cc) is_binary;
end-do

forall(pp in Paths) do
	create(u_UsePath(pp));
	u_UsePath(pp) is_binary;
end-do

forall (nn in Nodes, mm in Nodes) do
	create(l_Lambda(nn,mm));
end-do

forall (ss in Services, zz in Services | ss < zz) do
	create(l_Overlap(ss,zz));
	l_Overlap(ss,zz) is_binary;
end-do


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! CONSTRAINTS
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

declarations
! Objective function
	Total_Profits:																linctr;

! Constraints
	UsePath:						dynamic array(Services)							of linctr;
	PathArcBandwidth:				dynamic array(Nodes,Nodes)						of linctr;
	TotalBackup:					dynamic array(Nodes,Nodes)						of linctr;
	MaximumBackup:					dynamic array(Nodes,Nodes,Services)				of linctr;
	Overlap:						dynamic array(Nodes,Nodes,Services, Services)	of linctr;
	ServiceOverlap:					dynamic array(Nodes,Nodes,Services, Services)	of linctr;
end-declarations

write(" - obj. fn. ..");	

! OBJECTIVE FUNCTION
! - total profits from serving customers
Total_Profits := sum (cc in Customers) (
					! R_Revenue from serving customer (if served)
					R_Revenue(cc)*y_Serve(cc)
				)
				- 
				! cost for all paths used as main paths
				sum(kk in Paths) (
					!cost for using a path
					C_PathCost(kk)*u_UsePath(kk)
				)
				-
				! cost of bandwidth reserved to support backup paths
				sum(nn in Nodes) (
					sum(mm in Nodes) (
						C_BackupCost(nn, mm)*l_Lambda(nn, mm)
					)
				);

write("DONE\n - use path cnstr. ..");		


! USE PATH CONSTRAINTS
! If a service is placed at a provider, a path connecting to that provider location must be chosen
forall(cc in Customers) do
	forall(ss in S_ServiceForCustomer(cc) | exists(K_Paths(ss))) do
		UsePath(ss) := sum(kk in K_Paths(ss)) u_UsePath(kk) -y_Serve(cc) =0;
	end-do
end-do

write("DONE\n - arc cap cnstr. ..");	

! ARC CAPACITY CONSTRAINT
! The total used bandwidth for primary paths and reserved for backup paths must not exceed the
! arcs capacity
forall(nn in Nodes, mm in Nodes | exists(L_PathsUsingLink(nn,mm))) do
	PathArcBandwidth(nn,mm) := sum(kk in L_PathsUsingLink(nn,mm)) U_PathBandwidthUsage(nn,mm,kk)*u_UsePath(kk) + l_Lambda(nn,mm) 
		<= F_BandwidthCap(nn,mm);
end-do

write("DONE\n - backup path bw use cnstr. 1 ..");

! ACCUMULATIVE BACKUP PATHS BANDWIDTH CONSTRAINTS
! bandwidth reserved for backup paths on an arc is at least a fraction of the total bandwidth of all
! backup paths using that arc
forall( nn in Nodes, mm in Nodes | exists(L_PathsUsingLink(nn,mm))) do
	TotalBackup(nn,mm) := 0.3* sum(kk in L_PathsUsingLinkBackup(nn,mm))
		u_UsePath(kk)*(U_PathBandwidthUsageBackup(nn,mm,kk) - U_PathBandwidthUsage(nn,mm,kk)) 
		<= l_Lambda(nn,mm);
end-do

write("DONE\n - backup path bw use cnstr. 2 ..");

! MIN BACKUP PATH BANDWIDTH CONSTRAINT
! bandwidth reserved for backup paths must be at least as high as the bandwidth required by the
! most demanding backup path alone not also having its primary path at the same arc
! - if primary path goes down elsewhere - sufficient bandwidth is released for the backup path
!   at this arc
forall (cc in Customers) do
	forall(ss in S_ServiceForCustomer(cc)) do
		forall(nn in Nodes, mm in Nodes | exists(L_PathsUsingLinkBackup(nn,mm))) do
			MaximumBackup(nn,mm,ss) := sum(kk in (L_PathsUsingLinkBackup(nn,mm)*K_Paths(ss))) 
				(U_PathBandwidthUsageBackup(nn,mm,kk)-U_PathBandwidthUsage(nn,mm,kk))*u_UsePath(kk) 
				<= l_Lambda(nn,mm);
		end-do
	end-do
end-do

writeln("DONE\n - service and backup overlap cnstrs.");

forall(cc in Customers, qq in Customers) do
	forall(ss in S_ServiceForCustomer(cc), zz in S_ServiceForCustomer(qq) | ss <> zz and ss < zz) do
		writeln("  - service pair: ", ss, ", ", zz);
		forall(nn in Nodes, mm in Nodes | 	exists(L_PathsUsingLink(nn,mm)) 				! There are some paths using this arc
											and K_Paths(ss)*L_PathsUsingLink(nn,mm) <> {}	! Service ss has paths using this link
											and K_Paths(zz)*L_PathsUsingLink(nn,mm) <> {}	! Service zz has paths using this link
										) do
		
			! SERVICE PATH OVERLAP CONSTRAINTS
			! Two services have overlapping primary paths if for any arc both paths are represented
			ServiceOverlap(nn,mm,ss,zz):=
				sum(kk in (K_Paths(ss)*L_PathsUsingLink(nn,mm))) (u_UsePath(kk))
				+
				sum(kk in (K_Paths(zz)*L_PathsUsingLink(nn,mm))) (u_UsePath(kk))
				-1
				<= l_Overlap(ss, zz);
			
			! BACKUP PATH OVERLAP CONSTRAINT
			! backup paths may not overlap at an arc if their primary paths overlap anywhere, unless
			! one of the primary paths also overlap at that specific arc
			Overlap(nn,mm,ss,zz):= 
				sum(kk in (K_Paths(ss)*L_PathsUsingLinkBackup(nn,mm))) (u_UsePath(kk))
				+
				sum(kk in (K_Paths(zz)*L_PathsUsingLinkBackup(nn,mm))) (u_UsePath(kk))
				+ l_Overlap(ss, zz)
				<= 2;
		end-do
	end-do
end-do

writeln("  - DONE");


writeln("Model building completed in ", timestamp - timetracker, " seconds");

writeln("Solving model...");
timetracker := timestamp;
maximize(Total_Profits);

if (getprobstat=XPRS_OPT) then
	writeln("Model solved in ", timestamp - timetracker," seconds");
else
	writeln("Model was not solved after ", timestamp - timetracker," seconds");
end-if

writeln("\nTotal Profits: ", getobjval);

! for all customers
forall(cc in Customers) do
	! Check if customer is served
	if (getsol(y_Serve(cc)) > 0.1) then
		! output served customer and generated profits for customer
		writeln("\n\nCustomer ", cc, " (node ",cc,") is being served\n - R_Revenue: ",
			R_Revenue(cc)*getsol(y_Serve(cc)));
		forall(ss in S_ServiceForCustomer(cc) | exists(K_Paths(ss))) do
			forall(kk in K_Paths(ss)) do
				if (getsol(u_UsePath(kk)) > 0.1) then
					writeln("  - Service ",ss," uses path ",kk," , cost: ",C_PathCost(kk));
				end-if
			end-do
		end-do
	end-if
end-do
				

end-model
