!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!
!! BrokerCarrierOptimisation v1:
!!
!!- The following script implements the MIP model defined in chapter
!!	6 of Mari Holmen's and Sindre Møgster Braaten's project thesis
!!	fall 2013.
!!
!!- Authors: Mari Holmen and Sindre Møgster Braaten
!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

model BrokerCarrierOptimization
	
options explterm
options noimplicit

uses "mmxprs", "mmsystem";

parameters
	! Data file to read from
	Data = 'smallA.txt';
	! Use thightened restrictions (v2) or not (v1)
	TightenLP = false;
end-parameters

declarations
	timetracker:	real; ! used to log timestamps for time consumption output
end-declarations

writeln("Building model...");
timetracker := timestamp;

!setparam("XPRS_presolve", 0);	! uncomment to turn of presolve
setparam("XPRS_maxtime", 3600); ! maximum number of seconds for optimisation

!!!!!!!!!!!!!!!!!!!!!!!!
! Sets
!!!!!!!!!!!!!!!!!!!!!!!!

declarations
! Set sizes
	n_Customers: 			integer; ! number of customers
	n_Services:				integer; ! number of services
	n_Providers:			integer; ! number of providers
	n_Nodes:				integer; ! number of nodes in total
	
! Sets	
	Customers:				set of integer; 
	Providers:				set of integer;
	! Used as shorthand for 'cc in Customers, ss in S_ServiceForCustomer(cc)' when cc is not needed 
	Services:				set of integer;
	! Set of nodes in the network. 
	! - First we have the customer nodes, then the internal nodes, the the provider nodes.
	Nodes:					set of integer; 
	! Set of internal nodes in the network + all customer nodes 
	! - usage for internal nodes for each customer cc: 'nn in I_Nodes | nn<>cc'
	I_Nodes:				set of integer;
	! Node for each provider
	E_ProviderNode:			set of integer; 
end-declarations

initializations from Data
	n_Customers;
	n_Services;
	n_Providers;
	n_Nodes;
end-initializations
	
Customers:= 1..n_Customers;
Services:= 1..n_Services;  
Providers:= 1..n_Providers;
Nodes:= 1..n_Nodes;
I_Nodes:= 1..(n_Nodes-n_Providers);
E_ProviderNode:=(n_Nodes-n_Providers+1)..n_Nodes;

finalize(Customers);
finalize(Services);
finalize(Providers);
finalize(Nodes);
finalize(I_Nodes);
finalize(E_ProviderNode);

!!!!!!!!!!!!!!!!!!!!!!!
! Parameters
!!!!!!!!!!!!!!!!!!!!!!!

declarations
!Parameters
	!Price per leased capacity between nodes
	L_LeasedPrice:				dynamic array(Nodes,Nodes) of real;
	!Price per used capacity between nodes
	K_CapPrice:					dynamic array(Nodes,Nodes) of real;
	!R_Revenue from serving each customer
	R_Revenue:					dynamic array(Customers) of real;
	!Price of placing a service at a provider
	H_PlacePrice:				dynamic array(Services,Providers) of real;
	!Lists of services for each customer
	S_ServiceForCustomer:			set of set of integer; 
	!Latency requirement for each service from customer to provider
	G_LatencyReq:				array(Services) of real;
	!Latency limit for each service from provider to customer
	G_LatencyReqD:				array(Services) of real;
	!Bandwidth requirement for each service from customer to provider
	B_BandwidthReq:				array(Services) of real;
	!Bandwidth requirement for each service from provider to customer
	B_BandwidthReqD:			array(Services) of real;
	!Minimum avarage availability for each service
	Y_AvailabilityReq:			array(Services) of real; 
	!Lateny between each pair of nodes
	T_LinkLatency:				dynamic array(Nodes,Nodes) of real;
	!Bandwidth capacity between each pair of nodes
	F_BandwidthCap:				dynamic array(Nodes,Nodes) of real;
	!Latency for leased link between each pair of nodes
	V_LeaseLatency:				dynamic array(Nodes,Nodes) of real;
	!Maximum bandwidth capacity for leased link between each pair of nodes
	O_LeasedBandwidthCap:		dynamic array(Nodes,Nodes) of real;
	!Expected availability for each owned link between each pair of nodes
	D_AvailabilityExp:			dynamic array(Nodes,Nodes) of real;
	
! Network data interpretation configuration
	Symmetric:				boolean;

end-declarations

initialisations from Data
	L_LeasedPrice;					
	K_CapPrice;					
	R_Revenue;				
	H_PlacePrice;				
	S_ServiceForCustomer;				 				
	G_LatencyReq;	
	G_LatencyReqD;					
	B_BandwidthReq;
	B_BandwidthReqD;
	Y_AvailabilityReq;						
	T_LinkLatency;						
	F_BandwidthCap;						
	V_LeaseLatency;
	O_LeasedBandwidthCap;
	D_AvailabilityExp;
	
	Symmetric;
end-initialisations

! If Symmetric is set to true in provided dataset
! - duplicate all arcs in dataset in its opposite direction if opposite not already specified
if(Symmetric) then
	forall(nn in Nodes, mm in Nodes) do
		if(exists(L_LeasedPrice(nn,mm)) and not exists(L_LeasedPrice(mm,nn))) then
			create(L_LeasedPrice(mm,nn));
			L_LeasedPrice(mm,nn):= L_LeasedPrice(nn,mm);
		end-if
		
		if(exists(K_CapPrice(nn,mm)) and not exists(K_CapPrice(mm,nn))) then
			create(K_CapPrice(mm,nn));
			K_CapPrice(mm,nn):=K_CapPrice(nn,mm);
		end-if
		
		if(exists(T_LinkLatency(nn,mm)) and not exists(T_LinkLatency(mm,nn))) then
			create(T_LinkLatency(mm,nn));
			T_LinkLatency(mm,nn):=T_LinkLatency(nn,mm);
		end-if
		
		if(exists(F_BandwidthCap(nn,mm)) and not exists(F_BandwidthCap(mm,nn))) then
			create(F_BandwidthCap(mm,nn));
			F_BandwidthCap(mm,nn):=F_BandwidthCap(nn,mm);
		end-if
		
		if(exists(O_LeasedBandwidthCap(nn,mm)) and not exists(O_LeasedBandwidthCap(mm,nn))) then
			create(O_LeasedBandwidthCap(mm,nn));
			O_LeasedBandwidthCap(mm,nn):=O_LeasedBandwidthCap(nn,mm);
		end-if
		
		if(exists(V_LeaseLatency(nn,mm)) and not exists(V_LeaseLatency(mm,nn))) then
			create(V_LeaseLatency(mm,nn));
			V_LeaseLatency(mm,nn):=V_LeaseLatency(nn,mm);
		end-if
		if(exists(D_AvailabilityExp(nn,mm)) and not exists(D_AvailabilityExp(mm,nn))) then
			create(D_AvailabilityExp(mm,nn));
			D_AvailabilityExp(mm,nn) :=D_AvailabilityExp(nn,mm);
		end-if
	end-do
end-if

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Variables
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	
declarations	
	!Variables
	! - x: binary, placement of service at provider
	x_Placement: 		dynamic array (Services, Providers) 			of mpvar;
	! - u (up): continuous, use of own arc for service for uplink
	u_Capacity:			dynamic array (Nodes,Nodes,Services)			of mpvar;
	! - u (down): continuous, use of own arc for service for downlink
	u_CapacityDown:		dynamic array (Nodes,Nodes,Services)			of mpvar;
	! - y: binary, serving of a customer
	y_Serve:			dynamic array (Customers)						of mpvar;
	! - w (up): continuous, use of leased arc between nodes for a service (uplink)
	w_LeaseRes:			dynamic array (Nodes,Nodes,Services)			of mpvar;
	! - w (down): continuous, use of leased arc between nodes for a service (downlink)
	w_LeaseResDown:		dynamic array (Nodes,Nodes,Services)			of mpvar;
	! - u : binary, use of own arc for service either uplink or downlink
	v_UseLink:			dynamic array (Nodes,Nodes,Services)			of mpvar;
end-declarations	

! - for all valid combinations of service and provider
forall (ss in Services, pp in Providers | exists(H_PlacePrice(ss,pp))) do
	create (x_Placement(ss,pp));
	x_Placement(ss,pp) is_binary;
end-do

! - for all existing arcs in OWN network
forall(nn in Nodes, mm in Nodes, ss in Services | exists(F_BandwidthCap(nn,mm))) do
	! UPLINK
	create(u_Capacity(nn,mm,ss));
	u_Capacity(nn,mm,ss) <= 1;
	! DOWNLINK
	create(u_CapacityDown(nn,mm,ss));
	u_CapacityDown(nn,mm,ss) <=1;
	create(v_UseLink(nn,mm,ss));
	v_UseLink(nn,mm,ss) is_binary;
end-do

! - for all existing LEASABLE arcs
forall(nn in Nodes, mm in Nodes, ss in Services | exists(O_LeasedBandwidthCap(nn,mm))) do
	! UPLINK
	create(w_LeaseRes(nn,mm,ss));
	w_LeaseRes(nn,mm,ss) <=1;
	! DOWNLINK
	create(w_LeaseResDown(nn,mm,ss));
	w_LeaseResDown(nn,mm,ss) <=1;
end-do


! - for all customers
forall(cc in Customers) do
	create(y_Serve(cc));
	y_Serve(cc) is_binary;
end-do


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! CONSTRAINTS
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

declarations
! Objective function
	Total_Profits:																linctr;

! Constraints
	ServeCustomer:					dynamic array(Services)						of linctr;
	ArcCapacity:					dynamic array(Nodes,Nodes)					of linctr;	
	BandwidthFlow:					dynamic array(Services,I_Nodes)				of linctr;
	BandwidthFlowDown:				dynamic array(Services,I_Nodes)				of linctr;
	BandwidthRequirement:			dynamic array(Services,Providers)			of linctr;
	BandwidthRequirementDown:		dynamic array(Services,Providers)			of linctr;
	LatencyRequirement:				dynamic array(Services,Providers)			of linctr;
	LatencyRequirementDown:			dynamic array(Services)						of linctr;
	TotalLeasedCapacity:			dynamic array(Nodes,Nodes)					of linctr;
	UserSideBandwidth:				dynamic array(Services)						of linctr;
	UserSideBandwidthDown:			dynamic array(Services)						of linctr;
	AvailabilityBoundD:			dynamic array(Services)						of linctr;
	AvailabilityBoundU:			dynamic array(Services)						of linctr;
	AvailabilityRequirement:		dynamic array(Services)						of linctr;
	
	temp:	real;
end-declarations

! OBJECTIVE FUNCTION
! - total profits from serving customers
Total_Profits := sum (cc in Customers) 
					(
						! R_Revenue from serving customer (if served)
						R_Revenue(cc)*y_Serve(cc)
						- 
						! costs associated with customer's required services
						sum (ss in S_ServiceForCustomer(cc))
							(
								! placement cost
								sum (pp in Providers)
									H_PlacePrice(ss,pp)*x_Placement(ss,pp)
								+ 
								! network usage cost
								sum (nn in Nodes, mm in Nodes) 
									(K_CapPrice(nn,mm)
									*(u_Capacity(nn,mm,ss)*B_BandwidthReq(ss)+u_CapacityDown(nn,mm,ss)*B_BandwidthReqD(ss)))
								+ 
								! added costs from leasing
								sum (nn in Nodes, mm in Nodes)
									(L_LeasedPrice(nn,mm)
									*(w_LeaseRes(nn,mm,ss)*B_BandwidthReq(ss)+w_LeaseResDown(nn,mm,ss)*B_BandwidthReqD(ss)))
							)
					);

! SERVE CUSTOMER CONSTRAINT
! Customers can only be served if all services for customer is provided
forall(cc in Customers) do
	forall(ss in S_ServiceForCustomer(cc)) do
		ServeCustomer(ss) := sum (pp in Providers) x_Placement(ss,pp) - y_Serve(cc) = 0;
	end-do
end-do

! ARC TOTAL CAPACITY CONSTRAINT
! Use of an arc must not exceed its capacity (leased cap + owned cap)
forall (nn in Nodes, mm in Nodes
	| (exists(F_BandwidthCap(nn,mm)) or exists(O_LeasedBandwidthCap(nn,mm))))do
	ArcCapacity(nn,mm) := sum (ss in Services) (
			u_Capacity(nn,mm,ss)*B_BandwidthReq(ss) +u_CapacityDown(nn,mm,ss)*B_BandwidthReqD(ss)
		) <=F_BandwidthCap(nn,mm);
end-do



! BANDWIDTH FLOW CONSTRAINTS
! - bandwidth in to a node for a service must be equal to the flow out 
!	(unless a it is a provider node or the service's customer node)
forall (cc in Customers, ss in S_ServiceForCustomer(cc), nn in I_Nodes | nn<>cc ) do
 	BandwidthFlow(ss,nn) := (
	 		sum (mm in Nodes) (u_Capacity(nn,mm,ss)+w_LeaseRes(nn,mm,ss))
	 		- sum(mm in Nodes) (u_Capacity(mm,nn,ss)+w_LeaseRes(mm,nn,ss))
 		) = 0;
 	BandwidthFlowDown(ss,nn) := (
	 		sum (mm in Nodes) (u_CapacityDown(nn,mm,ss)+w_LeaseResDown(nn,mm,ss))
	 		- sum(mm in Nodes) (u_CapacityDown(mm,nn,ss)+w_LeaseResDown(mm,nn,ss))
 		) = 0;
end-do

! PLACEMENT SIDE BANDWIDTH REQUIREMENT CONSTRAINTS
! - bandwidth req. must be met for up-link/down-link for placement of service (else flow in = flow out)
forall (ss in Services,pp in Providers) do
	BandwidthRequirement(ss,pp) := (
			sum (nn in Nodes | nn<>E_ProviderNode(pp)) (u_Capacity(nn, E_ProviderNode(pp),ss)+w_LeaseRes(nn, E_ProviderNode(pp),ss)) 
			- sum(mm in Nodes | mm<>E_ProviderNode(pp)) (u_Capacity(E_ProviderNode(pp),mm,ss) + w_LeaseRes(E_ProviderNode(pp),mm,ss))
			-x_Placement(ss,pp)
		) = 0;
	BandwidthRequirementDown(ss,pp) := (
			sum (nn in Nodes | nn<>E_ProviderNode(pp)) (u_CapacityDown(E_ProviderNode(pp),nn,ss)+w_LeaseResDown(E_ProviderNode(pp),nn,ss)) 
			- sum(mm in Nodes | mm<>E_ProviderNode(pp)) (u_CapacityDown(mm,E_ProviderNode(pp),ss) + w_LeaseResDown(mm,E_ProviderNode(pp),ss))
			-x_Placement(ss,pp)
		) = 0;
end-do

! LATENCY REQUIREMENT CONSTRAINTS
! - user -> placement: for each service, latency for any used path to a provider must meet requirements
forall (ss in Services, pp in Providers) do
	LatencyRequirement(ss,pp) := 
			sum(nn in Nodes, mm in Nodes) ( T_LinkLatency(nn,mm)*u_Capacity(nn,mm,ss) 
			+ V_LeaseLatency(nn,mm)*w_LeaseRes(nn,mm,ss)) 
		<=  G_LatencyReq(ss);
end-do
! - placement->user: for each service, latency for any path from placement to customer must meet reqs.
forall(cc in Customers, ss in S_ServiceForCustomer(cc)) do
LatencyRequirementDown(ss) := 
			sum(nn in Nodes, mm in Nodes) ( T_LinkLatency(nn,mm)*u_CapacityDown(nn,mm,ss) 
			+ V_LeaseLatency(nn,mm)*w_LeaseResDown(nn,mm,ss)) 
		<=  G_LatencyReqD(ss);
end-do



! TOTAL LEASE CAPACITY CONSTRAINT
forall (nn in Nodes, mm in Nodes | exists(O_LeasedBandwidthCap(nn,mm))) do
	TotalLeasedCapacity(nn,mm) := (
			sum(ss in Services) (w_LeaseRes(nn,mm,ss)*B_BandwidthReq(ss) + w_LeaseResDown(nn,mm,ss)*B_BandwidthReqD(ss))
		) <= O_LeasedBandwidthCap(nn,mm);
end-do

! USER SIDE BANDWIDTH CONSTRAINTS
! bandwidth constraints for up-link and down-link must be met out of / in to user node
forall (cc in Customers, ss in S_ServiceForCustomer(cc)) do
	UserSideBandwidth(ss) := (
			sum(mm in Nodes | mm<>cc) (u_Capacity(cc,mm,ss) + w_LeaseRes(cc,mm,ss))
			- 
			sum(nn in Nodes | nn<>cc) (u_Capacity(nn,cc,ss)+w_LeaseRes(nn,cc,ss)) - y_Serve(cc)	
		)= 0;
	
	UserSideBandwidthDown(ss) := (
			sum(mm in Nodes | mm<>cc) (u_CapacityDown(mm,cc,ss) + w_LeaseResDown(mm,cc,ss))
			- 
			sum(nn in Nodes | nn<>cc) (u_CapacityDown(cc,nn,ss)+w_LeaseResDown(cc,nn,ss)) - y_Serve(cc)	
		)= 0;
end-do

forall (nn in Nodes, mm in Nodes, ss in Services) do
	AvailabilityBoundD(ss) := (
		v_UseLink(nn,mm,ss) - u_Capacity(nn,mm,ss) >= 0);
	AvailabilityBoundU(ss) := (
		v_UseLink(nn,mm,ss) - u_CapacityDown(nn,mm,ss) >=0);
end-do

forall (ss in Services) do
	AvailabilityRequirement(ss) := (
		sum( nn in Nodes, mm in Nodes) v_UseLink(nn,mm,ss)* ln(D_AvailabilityExp(nn,mm)) >= ln(Y_AvailabilityReq(ss)));
end-do
	




writeln("Model building completed in ", timestamp - timetracker, " seconds");

writeln("Solving model...");
timetracker := timestamp;
maximize(Total_Profits);

if (getprobstat=XPRS_OPT) then
	writeln("Model solved in ", timestamp - timetracker," seconds");
else
	writeln("Model was not solved after ", timestamp - timetracker," seconds");
end-if



!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!	Solution output:
! - this following part contains logic for outputting the solution as human
!	readable text and is not part of the model itself.
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


writeln("\nTotal Profits: ", getobjval);

! for all customers
forall(cc in Customers) do
	! Check if customer is served
	if (getsol(y_Serve(cc)) = 1) then
		! output served customer and generated profits for customer
		writeln("\n\nCustomer ", cc, " (node ",cc,") is being served\n - R_Revenue: ",
			R_Revenue(cc)*getsol(y_Serve(cc)),"\n - profits: ",(
				R_Revenue(cc)*getsol(y_Serve(cc))
				- 
				! costs associated with customer's required services
				sum (ss in S_ServiceForCustomer(cc))
					(
						! placement cost
						sum (pp in Providers)
							H_PlacePrice(ss,pp)*getsol(x_Placement(ss,pp))
						+ 
						! network usage cost
						sum (nn in Nodes, mm in Nodes) (
								K_CapPrice(nn,mm)*(getsol(u_Capacity(nn,mm,ss)*B_BandwidthReq(ss))
								+getsol(u_CapacityDown(nn,mm,ss)*B_BandwidthReq(ss)))
							)
						+ 
						! added costs from leasing
						sum (nn in Nodes, mm in Nodes)
							((L_LeasedPrice(nn,mm))
							*((getsol(w_LeaseRes(nn,mm,ss))*B_BandwidthReq(ss))+(getsol(w_LeaseResDown(nn,mm,ss))*B_BandwidthReq(ss))))
					)
				)
			);
	
		! output for all served customers services
		forall(ss in S_ServiceForCustomer(cc)) do
			! find and output provider placement for service
			forall(pp in Providers) do
				! find provider used for service
				if (getsol(x_Placement(ss,pp)) = 1) then
					writeln("\n - Service ",ss,":\n  - Costs: ", (
						! Calculate costs for this specific service
						H_PlacePrice(ss,pp)*getsol(x_Placement(ss,pp))
						+ 
						sum (nn in Nodes, mm in Nodes) (
							K_CapPrice(nn,mm)
							*( (getsol(u_Capacity(nn,mm,ss))*B_BandwidthReq(ss)) + (getsol(u_CapacityDown(nn,mm,ss))*B_BandwidthReq(ss)) )
						)
						+ 
						sum (nn in Nodes, mm in Nodes) (
							(L_LeasedPrice(nn,mm))
							*( (getsol(w_LeaseRes(nn,mm,ss))*B_BandwidthReq(ss)) + (getsol(w_LeaseResDown(nn,mm,ss))*B_BandwidthReq(ss)) )
						)), "\n  - placement: provider #", pp, " (node ",(n_Nodes-n_Providers+pp),
						") - Cost: ",H_PlacePrice(ss,pp));
			
					! output network routing for service
					! - up-link
					writeln("   - UPLINK:\n      - latency <= ,\n      - bandwidth: ", (sum(nn in Nodes) 
							B_BandwidthReq(ss)*getsol(u_Capacity(nn,(n_Nodes-n_Providers+pp),ss))),
						"   (Req. ",B_BandwidthReq(ss),")\n      - links usage:");
					forall(nn in Nodes, mm in Nodes) do
						if ((getsol(u_Capacity(nn,mm,ss)) >0 or getsol(w_LeaseRes(nn,mm,ss)) >0)) then
							writeln("        - (", nn, ",", mm, ") : ", B_BandwidthReq(ss)*(getsol(u_Capacity(nn,mm,ss))+getsol(w_LeaseRes(nn,mm,ss))), 
								"    (", getsol(w_LeaseRes(nn,mm,ss)), " leased) - Cost: ",
								K_CapPrice(nn,mm)*B_BandwidthReq(ss)*getsol(u_Capacity(nn,mm,ss))
								+ L_LeasedPrice(nn,mm)*B_BandwidthReq(ss)*getsol(w_LeaseRes(nn,mm,ss)) );
						end-if
					end-do
					writeln("      - leased capacity for links:");
					forall(nn in Nodes, mm in Nodes) do
						if (getsol(w_LeaseRes(nn,mm,ss)) >0) then
								writeln("        - (",nn,",",mm,"): ",B_BandwidthReq(ss)*getsol(w_LeaseRes(nn,mm,ss)),
									" - Cost: ", ((L_LeasedPrice(nn,mm)*B_BandwidthReq(ss))
									*getsol(w_LeaseRes(nn,mm,ss))));
						end-if
					end-do
					! - down-link
					writeln("   - DOWNLINK:\n      - latency <=  \n      - bandwidth: ", (sum(nn in Nodes) 
							B_BandwidthReq(ss)*getsol(u_CapacityDown(nn,(n_Nodes-n_Providers+pp),ss))),
						"   (Req. ",B_BandwidthReqD(ss),")\n      - links usage:");
					forall(nn in Nodes, mm in Nodes) do
						if ((getsol(u_CapacityDown(nn,mm,ss)) >0 or getsol(w_LeaseResDown(nn,mm,ss)) >0)) then
							writeln("        - (", nn, ",", mm, ") : ", B_BandwidthReq(ss)*(getsol(u_CapacityDown(nn,mm,ss))+getsol(w_LeaseResDown(nn,mm,ss))), 
								"    (", getsol(w_LeaseResDown(nn,mm,ss)), " leased) - Cost: ",
								K_CapPrice(nn,mm)*B_BandwidthReqD(ss)*getsol(u_CapacityDown(nn,mm,ss))
								+ L_LeasedPrice(nn,mm)*B_BandwidthReqD(ss)*getsol(w_LeaseResDown(nn,mm,ss)));
						end-if
					end-do
					writeln("      - leased capacity for links:");
					forall(nn in Nodes, mm in Nodes) do
						if (getsol(w_LeaseResDown(nn,mm,ss)) >0) then
								writeln("        - (",nn,",",mm,"): ",B_BandwidthReqD(ss)*getsol(w_LeaseResDown(nn,mm,ss)),
									" - Cost: ", ((L_LeasedPrice(nn,mm)*B_BandwidthReqD(ss))
									*getsol(w_LeaseResDown(nn,mm,ss))));
						end-if
					end-do!)
				end-if
			end-do
		end-do
	end-if
end-do

writeln("\n\nArcs with high utilisation of capacity (>=90%):");
forall(nn in Nodes, mm in Nodes | exists(F_BandwidthCap(nn,mm))) do
	if (sum(ss in Services) B_BandwidthReq(ss)*getsol(u_Capacity(nn,mm,ss))) >= F_BandwidthCap(nn,mm)*0.9 then
		writeln(" - (",nn,",",mm,") ", ( 
			100*sum(ss in Services) B_BandwidthReq(ss)*getsol(u_Capacity(nn,mm,ss)) / F_BandwidthCap(nn,mm))," %");
	end-if
end-do

writeln("\n\nArcs with medium utilisation of capacity (< 10%, < 90%):");
forall(nn in Nodes, mm in Nodes | exists(F_BandwidthCap(nn,mm))) do
	if ((sum(ss in Services)B_BandwidthReq(ss)*getsol(u_Capacity(nn,mm,ss))) > F_BandwidthCap(nn,mm)*0.1 and
		(sum(ss in Services)B_BandwidthReq(ss)*getsol(u_Capacity(nn,mm,ss))) < F_BandwidthCap(nn,mm)*0.9) then
		writeln(" - (",nn,",",mm,") ", (
			100*sum(ss in Services)(B_BandwidthReq(ss)*getsol(u_Capacity(nn,mm,ss))) / F_BandwidthCap(nn,mm))
		," %");
	end-if
end-do

(!writeln("\n\nArcs with low utilisation of capacity (<=10%):");
forall(nn in Nodes, mm in Nodes | exists(F_BandwidthCap(nn,mm))) do
	if (sum(ss in Services)(B_BandwidthReq(ss)*getsol(u_Capacity(nn,mm,ss)))) <= F_BandwidthCap(nn,mm)*0.1 then
		writeln(" - (",nn,",",mm,") ", (
			100*sum(ss in Services)(B_BandwidthReq(ss)*getsol(u_Capacity(nn,mm,ss))) / F_BandwidthCap(nn,mm))
		," %");
	end-if
end-do!)
end-model